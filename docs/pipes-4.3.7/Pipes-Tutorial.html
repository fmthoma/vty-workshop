<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Pipes.Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Pipes-Tutorial.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Pipes.Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">pipes-4.3.7: Compositional pipelines</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Pipes.Tutorial</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Introduction</a></li><li><a href="#g:2">Producers</a></li><li><a href="#g:3">Composability</a></li><li><a href="#g:4">Consumers</a></li><li><a href="#g:5">Pipes</a></li><li><a href="#g:6">ListT</a></li><li><a href="#g:7">Tricks</a></li><li><a href="#g:8">Conclusion</a></li><li><a href="#g:9">Appendix: Types</a></li><li><a href="#g:10">Appendix: Time Complexity</a></li><li><a href="#g:11">Copyright</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Conventional Haskell stream programming forces you to choose only two of the
    following three features:</p><ul><li>Effects</li><li>Streaming</li><li>Composability</li></ul><p>If you sacrifice <em>Effects</em> you get Haskell's pure and lazy lists, which you
    can transform using composable functions in constant space, but without
    interleaving effects.</p><p>If you sacrifice <em>Streaming</em> you get <code><a href="../base-4.9.1.0/Data-Traversable.html#v:mapM">mapM</a></code>, <code><a href="../base-4.9.1.0/Data-Traversable.html#v:forM">forM</a></code> and
    &quot;ListT done wrong&quot;, which are composable and effectful, but do not return
    a single result until the whole list has first been processed and loaded
    into memory.</p><p>If you sacrifice <em>Composability</em> you write a tightly coupled read,
    transform, and write loop in <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code>, which is streaming and effectful, but is
    not modular or separable.</p><p><code>pipes</code> gives you all three features: effectful, streaming, and composable
    programming.  <code>pipes</code> also provides a wide variety of stream programming
    abstractions which are all subsets of a single unified machinery:</p><ul><li>effectful <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s (like generators),</li><li>effectful <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s (like iteratees),</li><li>effectful <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s (like Unix pipes), and:</li><li><code><a href="Pipes.html#t:ListT">ListT</a></code> done right.</li></ul><p>All of these are connectable and you can combine them together in clever and
    unexpected ways because they all share the same underlying type.</p><p><code>pipes</code> requires a basic understanding of monad transformers, which you can
    learn about by reading either:</p><ul><li>the paper &quot;Monad Transformers - Step by Step&quot;,</li><li>part III &quot;Monads in the Real World&quot; of the tutorial &quot;All About Monads&quot;,</li><li>chapter 18 of &quot;Real World Haskell&quot; on monad transformers, or:</li><li>the documentation of the <code>transformers</code> library.</li></ul><p>If you want a Quick Start guide to <code>pipes</code>, read the documentation in
    <a href="Pipes-Prelude.html">Pipes.Prelude</a> from top to bottom.</p><p>This tutorial is more extensive and explains the <code>pipes</code> API in greater
    detail and illustrates several idioms.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"></ul></div><div id="interface"><h1 id="g:1">Introduction</h1><div class="doc"><p>The <code>pipes</code> library decouples stream processing stages from each other so
    that you can mix and match diverse stages to produce useful streaming
    programs.  If you are a library writer, <code>pipes</code> lets you package up
    streaming components into a reusable interface.  If you are an application
    writer, <code>pipes</code> lets you connect pre-made streaming components with minimal
    effort to produce a highly-efficient program that streams data in constant
    memory.</p><p>To enforce loose coupling, components can only communicate using two
    commands:</p><ul><li><code><a href="Pipes.html#v:yield">yield</a></code>: Send output data</li><li><code><a href="Pipes.html#v:await">await</a></code>: Receive input data</li></ul><p><code>pipes</code> has four types of components built around these two commands:</p><ul><li><code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s can only <code><a href="Pipes.html#v:yield">yield</a></code> values and they model streaming sources</li><li><code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s can only <code><a href="Pipes.html#v:await">await</a></code> values and they model streaming sinks</li><li><code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s can both <code><a href="Pipes.html#v:yield">yield</a></code> and <code><a href="Pipes.html#v:await">await</a></code> values and they model stream
      transformations</li><li><code><a href="Pipes-Core.html#t:Effect">Effect</a></code>s can neither <code><a href="Pipes.html#v:yield">yield</a></code> nor <code><a href="Pipes.html#v:await">await</a></code> and they model non-streaming
      components</li></ul><p>You can connect these components together in four separate ways which
    parallel the four above types:</p><ul><li><code><a href="Pipes.html#v:for">for</a></code> handles <code><a href="Pipes.html#v:yield">yield</a></code>s</li><li>(<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) handles <code><a href="Pipes.html#v:await">await</a></code>s</li><li>(<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) handles both <code><a href="Pipes.html#v:yield">yield</a></code>s and <code><a href="Pipes.html#v:await">await</a></code>s</li><li>(<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) handles return values</li></ul><p>As you connect components their types will change to reflect inputs and
    outputs that you've fused away.  You know that you're done connecting things
    when you get an <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>, meaning that you have handled all inputs and
    outputs.  You run this final <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> to begin streaming.</p></div><h1 id="g:2">Producers</h1><div class="doc"><p><code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s are effectful streams of input.  Specifically, a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> is a
    monad transformer that extends any base monad with a new <code><a href="Pipes.html#v:yield">yield</a></code> command.
    This <code><a href="Pipes.html#v:yield">yield</a></code> command lets you send output downstream to an anonymous
    handler, decoupling how you generate values from how you consume them.</p><p>The following <code>stdinLn</code> <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> shows how to incrementally read in
    <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>s from standard input and <code><a href="Pipes.html#v:yield">yield</a></code> them downstream, terminating
    gracefully when reaching the end of the input:</p><pre>-- echo.hs

import Control.Monad (unless)
import Pipes
import System.IO (isEOF)

--         +--------+-- A 'Producer' that yields 'String's
--         |        |
--         |        |      +-- Every monad transformer has a base monad.
--         |        |      |   This time the base monad is 'IO'.
--         |        |      |  
--         |        |      |  +-- Every monadic action has a return value.
--         |        |      |  |   This action returns '()' when finished
--         v        v      v  v
stdinLn :: Producer String IO ()
stdinLn = do
    eof &lt;- lift isEOF        -- 'lift' an 'IO' action from the base monad
    unless eof $ do
        str &lt;- lift getLine
        yield str            -- 'yield' the 'String'
        stdinLn              -- Loop</pre><p><code><a href="Pipes.html#v:yield">yield</a></code> emits a value, suspending the current <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> until the value is
    consumed.  If nobody consumes the value (which is possible) then <code><a href="Pipes.html#v:yield">yield</a></code>
    never returns.  You can think of <code><a href="Pipes.html#v:yield">yield</a></code> as having the following type:</p><pre> <code><a href="Pipes.html#v:yield">yield</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m ()
</pre><p>The true type of <code><a href="Pipes.html#v:yield">yield</a></code> is actually more general and powerful.  Throughout
    the tutorial I will present type signatures like this that are simplified at
    first and then later reveal more general versions.  So read the above type
    signature as simply saying: &quot;You can use <code><a href="Pipes.html#v:yield">yield</a></code> within a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>, but
    you may be able to use <code><a href="Pipes.html#v:yield">yield</a></code> in other contexts, too.&quot;</p><p>Click the link to <code><a href="Pipes.html#v:yield">yield</a></code> to navigate to its documentation.  There you will
    see that <code><a href="Pipes.html#v:yield">yield</a></code> actually uses the <code><a href="Pipes-Core.html#t:Producer-39-">Producer'</a></code> (with an apostrophe) type
    synonym which hides a lot of polymorphism behind a simple veneer.  The
    documentation for <code><a href="Pipes.html#v:yield">yield</a></code> says that you can also use <code><a href="Pipes.html#v:yield">yield</a></code> within a
    <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>, too, because of this polymorphism:</p><pre> <code><a href="Pipes.html#v:yield">yield</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; a -&gt; <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> x a m ()
</pre><p>Use simpler types like these to guide you until you understand the fully
    general type.</p><p><code><a href="Pipes.html#v:for">for</a></code> loops are the simplest way to consume a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> like <code>stdinLn</code>.
    <code><a href="Pipes.html#v:for">for</a></code> has the following type:</p><pre> --                +-- Producer      +-- The body of the   +-- Result
 --                |   to loop       |   loop              |
 --                v   over          v                     v
 --                --------------    ------------------    ----------
 <code><a href="Pipes.html#v:for">for</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m r -&gt; (a -&gt; <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> m ()) -&gt; <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> m r
</pre><p><code>(for producer body)</code> loops over <code>(producer)</code>, substituting each <code><a href="Pipes.html#v:yield">yield</a></code> in
    <code>(producer)</code> with <code>(body)</code>.</p><p>You can also deduce that behavior purely from the type signature:</p><ul><li>The body of the loop takes exactly one argument of type <code>(a)</code>, which is
      the same as the output type of the <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>.  Therefore, the body of the
      loop must get its input from that <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> and nowhere else.</li><li>The return value of the input <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> matches the return value of the
      result, therefore <code><a href="Pipes.html#v:for">for</a></code> must loop over the entire <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> and not skip
      anything.</li></ul><p>The above type signature is not the true type of <code><a href="Pipes.html#v:for">for</a></code>, which is actually
    more general.  Think of the above type signature as saying: &quot;If the first
    argument of <code><a href="Pipes.html#v:for">for</a></code> is a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> and the second argument returns an
    <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>, then the final result must be an <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>.&quot;</p><p>Click the link to <code><a href="Pipes.html#v:for">for</a></code> to navigate to its documentation.  There you will
    see the fully general type and underneath you will see equivalent simpler
    types.  One of these says that if the body of the loop is a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>, then
    the result is a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>, too:</p><pre> <code><a href="Pipes.html#v:for">for</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m r -&gt; (a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> b m ()) -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> b m r
</pre><p>The first type signature I showed for <code><a href="Pipes.html#v:for">for</a></code> was a special case of this
    slightly more general signature because a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> that never <code><a href="Pipes.html#v:yield">yield</a></code>s is
    also an <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>:</p><pre> data <code><a href="Pipes-Internal.html#t:X">X</a></code>  -- The uninhabited type

 type <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> m r = <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> <code><a href="Pipes-Internal.html#t:X">X</a></code> m r
</pre><p>This is why <code><a href="Pipes.html#v:for">for</a></code> permits two different type signatures.  The first type
    signature is just a special case of the second one:</p><pre> <code><a href="Pipes.html#v:for">for</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m r -&gt; (a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> b m ()) -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> b m r

 -- Specialize 'b' to 'X'
 <code><a href="Pipes.html#v:for">for</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m r -&gt; (a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> <code><a href="Pipes-Internal.html#t:X">X</a></code> m ()) -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> <code><a href="Pipes-Internal.html#t:X">X</a></code> m r

 -- Producer X = Effect
 <code><a href="Pipes.html#v:for">for</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m r -&gt; (a -&gt; <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>     m ()) -&gt; <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>     m r
</pre><p>This is the same trick that all <code>pipes</code> functions use to work with various
    combinations of <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s, <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s, <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s, and <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>s.  Each
    function really has just one general type, which you can then simplify down
    to multiple useful alternative types.</p><p>Here's an example use of a <code><a href="Pipes.html#v:for">for</a></code> <code>loop</code>, where the second argument (the
    loop body) is an <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>:</p><pre>-- echo.hs

loop :: Effect IO ()
loop = for stdinLn $ \str -&gt; do  -- Read this like: &quot;for str in stdinLn&quot;
    lift $ putStrLn str          -- The body of the 'for' loop

-- more concise: loop = for stdinLn (lift . putStrLn)</pre><p>In this example, <code><a href="Pipes.html#v:for">for</a></code> loops over <code>stdinLn</code> and replaces every <code><a href="Pipes.html#v:yield">yield</a></code> in
    <code>stdinLn</code> with the body of the loop, printing each line.  This is exactly
    equivalent to the following code, which I've placed side-by-side with the
    original definition of <code>stdinLn</code> for comparison:</p><pre>loop = do                      |  stdinLn = do
    eof &lt;- lift isEOF          |      eof &lt;- lift isEOF
    unless eof $ do            |      unless eof $ do
        str &lt;- lift getLine    |          str &lt;- lift getLine
        (lift . putStrLn) str  |          yield str
        loop                   |          stdinLn</pre><p>You can think of <code><a href="Pipes.html#v:yield">yield</a></code> as creating a hole and a <code><a href="Pipes.html#v:for">for</a></code> loop is one way to
    fill that hole.</p><p>Notice how the final <code>loop</code> only <code><a href="../mmorph-1.0.9/Control-Monad-Morph.html#v:lift">lift</a></code>s actions from the base monad and
    does nothing else.  This property is true for all <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>s, which are just
    glorified wrappers around actions in the base monad.  This means we can run
    these <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>s to remove their <code><a href="../mmorph-1.0.9/Control-Monad-Morph.html#v:lift">lift</a></code>s and lower them back to the
    equivalent computation in the base monad:</p><pre> <code><a href="Pipes-Core.html#v:runEffect">runEffect</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> m r -&gt; m r
</pre><p>This is the real type signature of <code><a href="Pipes-Core.html#v:runEffect">runEffect</a></code>, which refuses to accept
    anything other than an <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>.  This ensures that we handle all inputs and
    outputs before streaming data:</p><pre>-- echo.hs

main :: IO ()
main = runEffect loop</pre><p>... or you could inline the entire <code>loop</code> into the following one-liner:</p><pre>main = runEffect $ for stdinLn (lift . putStrLn)</pre><p>Our final program loops over standard input and echoes every line to
    standard output until we hit <code>Ctrl-D</code> to end the input stream:</p><pre>$ ghc -O2 echo.hs
$ ./echo
Test&lt;Enter&gt;
Test
ABC&lt;Enter&gt;
ABC
&lt;Ctrl-D&gt;
$</pre><p>The final behavior is indistinguishable from just removing all the <code><a href="../mmorph-1.0.9/Control-Monad-Morph.html#v:lift">lift</a></code>s
    from <code>loop</code>:</p><pre>main = do               |  loop = do
    eof &lt;- isEof        |      eof &lt;- lift isEof
    unless eof $ do     |      unless eof $ do
        str &lt;- getLine  |          str &lt;- lift getLine
        putStrLn str    |          (lift . putStrLn) str
        main            |          loop</pre><p>This <code>main</code> is what we might have written by hand if we were not using
    <code>pipes</code>, but with <code>pipes</code> we can decouple the input and output logic from
    each other.  When we connect them back together, we still produce streaming
    code equivalent to what a sufficiently careful Haskell programmer would
    have written.</p><p>You can also use <code><a href="Pipes.html#v:for">for</a></code> to loop over lists, too.  To do so, convert the list
    to a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> using <code><a href="Pipes.html#v:each">each</a></code>, which is exported by default from <a href="Pipes.html">Pipes</a>:</p><pre>each :: Monad m =&gt; [a] -&gt; Producer a m ()
each as = mapM_ yield as</pre><p>Combine <code><a href="Pipes.html#v:for">for</a></code> and <code><a href="Pipes.html#v:each">each</a></code> to iterate over lists using a &quot;foreach&quot; loop:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ for (each [1..4]) (lift . print)
</code></strong>1
2
3
4
</pre><p><code><a href="Pipes.html#v:each">each</a></code> is actually more general and works for any <code><a href="Pipes.html#t:Foldable">Foldable</a></code>:</p><pre> <code><a href="Pipes.html#v:each">each</a></code> :: (<code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m, <code><a href="Pipes.html#t:Foldable">Foldable</a></code> f) =&gt; f a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m ()
</pre><p>So you can loop over any <code><a href="Pipes.html#t:Foldable">Foldable</a></code> container or even a <code><a href="../base-4.9.1.0/Data-Maybe.html#t:Maybe">Maybe</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ for (each (Just 1)) (lift . print)
</code></strong>1
</pre></div><h1 id="g:3">Composability</h1><div class="doc"><p>You might wonder why the body of a <code><a href="Pipes.html#v:for">for</a></code> loop can be a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>.  Let's
    test out this feature by defining a new loop body that creates three copies
    of every value:</p><pre>-- nested.hs

import Pipes
import qualified Pipes.Prelude as P  -- Pipes.Prelude already has 'stdinLn'

triple :: Monad m =&gt; a -&gt; Producer a m ()
triple x = do
    yield x
    yield x
    yield x

loop :: Producer String IO ()
loop = for P.stdinLn triple

-- This is the exact same as:
--
-- loop = for P.stdinLn $ \x -&gt; do
--     yield x
--     yield x
--     yield x</pre><p>This time our <code>loop</code> is a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> that outputs <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>s, specifically
    three copies of each line that we read from standard input.  Since <code>loop</code> is
    a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> we cannot run it because there is still unhandled output.
    However, we can use yet another <code><a href="Pipes.html#v:for">for</a></code> to handle this new repeated stream:</p><pre>-- nested.hs

main = runEffect $ for loop (lift . putStrLn)</pre><p>This creates a program which echoes every line from standard input to
    standard output three times:</p><pre>$ ./nested
Test&lt;Enter&gt;
Test
Test
Test
ABC&lt;Enter&gt;
ABC
ABC
ABC
&lt;Ctrl-D&gt;
$</pre><p>But is this really necessary?  Couldn't we have instead written this using a
    nested for loop?</p><pre>main = runEffect $
    for P.stdinLn $ \str1 -&gt;
        for (triple str1) $ \str2 -&gt;
            lift $ putStrLn str2</pre><p>Yes, we could have!  In fact, this is a special case of the following
    equality, which always holds no matter what:</p><pre> -- s :: Monad m =&gt;      <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m ()  -- i.e. 'P.stdinLn'
 -- f :: Monad m =&gt; a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> b m ()  -- i.e. 'triple'
 -- g :: Monad m =&gt; b -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> c m ()  -- i.e. '(lift . putStrLn)'

 for (for s f) g = for s (\x -&gt; for (f x) g)
</pre><p>We can understand the rationale behind this equality if we first define the
    following operator that is the point-free counterpart to <code><a href="Pipes.html#v:for">for</a></code>:</p><pre> (~&gt;) :: Monad m
      =&gt; (a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> b m ())
      -&gt; (b -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> c m ())
      -&gt; (a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> c m ())
 (f ~&gt; g) x = for (f x) g
</pre><p>Using (<code><a href="Pipes.html#v:-126--62-">~&gt;</a></code>) (pronounced &quot;into&quot;), we can transform our original equality
    into the following more symmetric equation:</p><pre> f :: Monad m =&gt; a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> b m ()
 g :: Monad m =&gt; b -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> c m ()
 h :: Monad m =&gt; c -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> d m ()

 -- Associativity
 (f ~&gt; g) ~&gt; h = f ~&gt; (g ~&gt; h)
</pre><p>This looks just like an associativity law.  In fact, (<code><a href="Pipes.html#v:-126--62-">~&gt;</a></code>) has another nice
    property, which is that <code><a href="Pipes.html#v:yield">yield</a></code> is its left and right identity:</p><pre>-- Left Identity
yield ~&gt; f = f</pre><pre>-- Right Identity
f ~&gt; yield = f</pre><p>In other words, <code><a href="Pipes.html#v:yield">yield</a></code> and (<code><a href="Pipes.html#v:-126--62-">~&gt;</a></code>) form a <code><a href="../base-4.9.1.0/Control-Category.html#t:Category">Category</a></code>, specifically the
    generator category, where (<code><a href="Pipes.html#v:-126--62-">~&gt;</a></code>) plays the role of the composition operator
    and <code><a href="Pipes.html#v:yield">yield</a></code> is the identity.  If you don't know what a <code><a href="../base-4.9.1.0/Control-Category.html#t:Category">Category</a></code> is, that's
    okay, and category theory is not a prerequisite for using <code>pipes</code>.  All you
    really need to know is that <code>pipes</code> uses some simple category theory to keep
    the API intuitive and easy to use.</p><p>Notice that if we translate the left identity law to use <code><a href="Pipes.html#v:for">for</a></code> instead of
    (<code><a href="Pipes.html#v:-126--62-">~&gt;</a></code>) we get:</p><pre>for (yield x) f = f x</pre><p>This just says that if you iterate over a pure single-element <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>,
    then you could instead cut out the middle man and directly apply the body of
    the loop to that single element.</p><p>If we translate the right identity law to use <code><a href="Pipes.html#v:for">for</a></code> instead of (<code><a href="Pipes.html#v:-126--62-">~&gt;</a></code>) we
    get:</p><pre>for s yield = s</pre><p>This just says that if the only thing you do is re-<code><a href="Pipes.html#v:yield">yield</a></code> every element of
    a stream, you get back your original stream.</p><p>These three &quot;for loop&quot; laws summarize our intuition for how <code><a href="Pipes.html#v:for">for</a></code> loops
    should behave and because these are <code><a href="../base-4.9.1.0/Control-Category.html#t:Category">Category</a></code> laws in disguise that means
    that <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s are composable in a rigorous sense of the word.</p><p>In fact, we get more out of this than just a bunch of equations.  We also
    get a useful operator: (<code><a href="Pipes.html#v:-126--62-">~&gt;</a></code>).  We can use this operator to condense
    our original code into the following more succinct form that composes two
    transformations:</p><pre>main = runEffect $ for P.stdinLn (triple ~&gt; lift . putStrLn)</pre><p>This means that we can also choose to program in a more functional style and
    think of stream processing in terms of composing transformations using
    (<code><a href="Pipes.html#v:-126--62-">~&gt;</a></code>) instead of nesting a bunch of <code><a href="Pipes.html#v:for">for</a></code> loops.</p><p>The above example is a microcosm of the design philosophy behind the <code>pipes</code>
    library:</p><ul><li>Define the API in terms of categories</li><li>Specify expected behavior in terms of category laws</li><li>Think compositionally instead of sequentially</li></ul></div><h1 id="g:4">Consumers</h1><div class="doc"><p>Sometimes you don't want to use a <code><a href="Pipes.html#v:for">for</a></code> loop because you don't want to consume
    every element of a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> or because you don't want to process every
    value of a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> the exact same way.</p><p>The most general solution is to externally iterate over the <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> using
    the <code><a href="Pipes.html#v:next">next</a></code> command:</p><pre> <code><a href="Pipes.html#v:next">next</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m r -&gt; m (<code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> r (a, <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m r))
</pre><p>Think of <code><a href="Pipes.html#v:next">next</a></code> as pattern matching on the head of the <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>.  This
    <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> returns a <code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code> if the <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> is done or it returns a <code><a href="../base-4.9.1.0/Data-Either.html#v:Right">Right</a></code>
    containing the next value, <code>a</code>, along with the remainder of the <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>.</p><p>However, sometimes we can get away with something a little more simple and
    elegant, like a <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>, which represents an effectful sink of values.  A
    <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> is a monad transformer that extends the base monad with a new
    <code><a href="Pipes.html#v:await">await</a></code> command. This <code><a href="Pipes.html#v:await">await</a></code> command lets you receive input from an
    anonymous upstream source.</p><p>The following <code>stdoutLn</code> <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> shows how to incrementally <code><a href="Pipes.html#v:await">await</a></code>
    <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>s and print them to standard output, terminating gracefully when
    receiving a broken pipe error:</p><pre>import Control.Monad (unless)
import Control.Exception (try, throwIO)
import qualified GHC.IO.Exception as G
import Pipes

--          +--------+-- A 'Consumer' that awaits 'String's
--          |        |
--          v        v
stdoutLn :: Consumer String IO ()
stdoutLn = do
    str &lt;- await  -- 'await' a 'String'
    x   &lt;- lift $ try $ putStrLn str
    case x of
        -- Gracefully terminate if we got a broken pipe error
        Left e@(G.IOError { G.ioe_type = t}) -&gt;
            lift $ unless (t == G.ResourceVanished) $ throwIO e
        -- Otherwise loop
        Right () -&gt; stdoutLn</pre><p><code><a href="Pipes.html#v:await">await</a></code> is the dual of <code><a href="Pipes.html#v:yield">yield</a></code>: we suspend our <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> until we receive a
    new value.  If nobody provides a value (which is possible) then <code><a href="Pipes.html#v:await">await</a></code>
    never returns.  You can think of <code><a href="Pipes.html#v:await">await</a></code> as having the following type:</p><pre> <code><a href="Pipes.html#v:await">await</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> a m a
</pre><p>One way to feed a <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> is to repeatedly feed the same input using
    (<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) (pronounced &quot;feed&quot;):</p><pre> --                 +- Feed       +- Consumer to    +- Returns new
 --                 |  action     |  feed           |  Effect
 --                 v             v                 v  
 --                 ----------    --------------    ----------
 (<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> m b -&gt; <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> b m c -&gt; <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> m c
</pre><p><code>(draw &gt;~ consumer)</code> loops over <code>(consumer)</code>, substituting each <code><a href="Pipes.html#v:await">await</a></code> in
    <code>(consumer)</code> with <code>(draw)</code>.</p><p>So the following code replaces every <code><a href="Pipes.html#v:await">await</a></code> in <code><a href="Pipes-Prelude.html#v:stdoutLn">stdoutLn</a></code> with
    <code>(lift getLine)</code> and then removes all the <code><a href="../mmorph-1.0.9/Control-Monad-Morph.html#v:lift">lift</a></code>s:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ lift getLine &gt;~ stdoutLn
</code></strong>Test&lt;Enter&gt;
Test
ABC&lt;Enter&gt;
ABC
42&lt;Enter&gt;
42
...
</pre><p>You might wonder why (<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) uses an <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> instead of a raw action in the
    base monad.  The reason why is that (<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) actually permits the following
    more general type:</p><pre> (<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> a m b -&gt; <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> b m c -&gt; <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> a m c
</pre><p>(<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) is the dual of (<code><a href="Pipes.html#v:-126--62-">~&gt;</a></code>), composing <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s instead of <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s.</p><p>This means that you can feed a <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> with yet another <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> so
    that you can <code><a href="Pipes.html#v:await">await</a></code> while you <code><a href="Pipes.html#v:await">await</a></code>.  For example, we could define the
    following intermediate <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> that requests two <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>s and returns
    them concatenated:</p><pre>doubleUp :: Monad m =&gt; Consumer String m String
doubleUp = do
    str1 &lt;- await
    str2 &lt;- await
    return (str1 ++ str2)

-- more concise: doubleUp = (++) &lt;$&gt; await &lt;*&gt; await</pre><p>We can now insert this in between <code>(lift getLine)</code> and <code>stdoutLn</code> and see
    what happens:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ lift getLine &gt;~ doubleUp &gt;~ stdoutLn
</code></strong>Test&lt;Enter&gt;
ing&lt;Enter&gt;
Testing
ABC&lt;Enter&gt;
DEF&lt;Enter&gt;
ABCDEF
42&lt;Enter&gt;
000&lt;Enter&gt;
42000
...
</pre><p><code>doubleUp</code> splits every request from <code>stdoutLn</code> into two separate requests
    and
    returns back the concatenated result.</p><p>We didn't need to parenthesize the above chain of (<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) operators, because
    (<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) is associative:</p><pre>-- Associativity
(f &gt;~ g) &gt;~ h = f &gt;~ (g &gt;~ h)</pre><p>... so we can always omit the parentheses since the meaning is unambiguous:</p><pre>f &gt;~ g &gt;~ h</pre><p>Also, (<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) has an identity, which is <code><a href="Pipes.html#v:await">await</a></code>!</p><pre>-- Left identity
await &gt;~ f = f

-- Right Identity
f &gt;~ await = f</pre><p>In other words, (<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>) and <code><a href="Pipes.html#v:await">await</a></code> form a <code><a href="../base-4.9.1.0/Control-Category.html#t:Category">Category</a></code>, too, specifically the
    iteratee category, and <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s are also composable.</p></div><h1 id="g:5">Pipes</h1><div class="doc"><p>Our previous programs were unsatisfactory because they were biased either
    towards the <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> end or the <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> end.  As a result, we had to
    choose between gracefully handling end of input (using <code><a href="Pipes-Prelude.html#v:stdinLn">stdinLn</a></code>) or
    gracefully handling end of output (using <code><a href="Pipes-Prelude.html#v:stdoutLn">stdoutLn</a></code>), but not both at the
    same time.</p><p>However, we don't need to restrict ourselves to using <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s
    exclusively or <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s exclusively.  We can connect <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s and
    <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s directly together using (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) (pronounced &quot;pipe&quot;):</p><pre> (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m r -&gt; <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> a m r -&gt; <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> m r
</pre><p>This returns an <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> which we can run:</p><pre>-- echo2.hs

import Pipes
import qualified Pipes.Prelude as P  -- Pipes.Prelude also provides 'stdoutLn'

main = runEffect $ P.stdinLn &gt;-&gt; P.stdoutLn</pre><p>This program is more declarative of our intent: we want to stream values
    from <code><a href="Pipes-Prelude.html#v:stdinLn">stdinLn</a></code> to <code><a href="Pipes-Prelude.html#v:stdoutLn">stdoutLn</a></code>.  The above &quot;pipeline&quot; not only echoes
    standard input to standard output, but also handles both end of input and
    broken pipe errors:</p><pre>$ ./echo2
Test&lt;Enter&gt;
Test
ABC&lt;Enter&gt;
ABC
42&lt;Enter&gt;
42
&lt;Ctrl-D&gt;
$</pre><p>(<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) is &quot;pull-based&quot; meaning that control flow begins at the most
    downstream component (i.e. <code><a href="Pipes-Prelude.html#v:stdoutLn">stdoutLn</a></code> in the above example).  Any time a
    component <code><a href="Pipes.html#v:await">await</a></code>s a value it blocks and transfers control upstream and
    every time a component <code><a href="Pipes.html#v:yield">yield</a></code>s a value it blocks and restores control back
    downstream, satisfying the <code><a href="Pipes.html#v:await">await</a></code>.  So in the above example, (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>)
    matches every <code><a href="Pipes.html#v:await">await</a></code> from <code><a href="Pipes-Prelude.html#v:stdoutLn">stdoutLn</a></code> with a <code><a href="Pipes.html#v:yield">yield</a></code> from <code><a href="Pipes-Prelude.html#v:stdinLn">stdinLn</a></code>.</p><p>Streaming stops when either <code><a href="Pipes-Prelude.html#v:stdinLn">stdinLn</a></code> terminates (i.e. end of input) or
    <code><a href="Pipes-Prelude.html#v:stdoutLn">stdoutLn</a></code> terminates (i.e. broken pipe).  This is why (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) requires
    that both the <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> and <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> share the same type of return value:
    whichever one terminates first provides the return value for the entire
    <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>.</p><p>Let's test this by modifying our <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> and <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> to each return a
    diagnostic <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>:</p><pre>-- echo3.hs

import Control.Applicative ((&lt;$))  -- (&lt;$) modifies return values
import Pipes
import qualified Pipes.Prelude as P
import System.IO

main = do
    hSetBuffering stdout NoBuffering
    str &lt;- runEffect $
        (&quot;End of input!&quot; &lt;$ P.stdinLn) &gt;-&gt; (&quot;Broken pipe!&quot; &lt;$ P.stdoutLn)
    hPutStrLn stderr str</pre><p>This lets us diagnose whether the <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> or <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> terminated first:</p><pre>$ ./echo3
Test&lt;Enter&gt;
Test
&lt;Ctrl-D&gt;
End of input!
$ ./echo3 | perl -e 'close STDIN'
Test&lt;Enter&gt;
Broken pipe!
$</pre><p>You might wonder why (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) returns an <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> that we have to run instead
    of directly returning an action in the base monad.  This is because you can
    connect things other than <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s and <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s, like <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s, which
    are effectful stream transformations.</p><p>A <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> is a monad transformer that is a mix between a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> and
    <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>, because a <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> can both <code><a href="Pipes.html#v:await">await</a></code> and <code><a href="Pipes.html#v:yield">yield</a></code>.  The following
    example <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> is analagous to the Prelude's <code><a href="../base-4.9.1.0/GHC-OldList.html#v:take">take</a></code>, only allowing a fixed
    number of values to flow through:</p><pre>-- take.hs

import Control.Monad (replicateM_)
import Pipes
import Prelude hiding (take)

--              +--------- A 'Pipe' that
--              |    +---- 'await's 'a's and
--              |    | +-- 'yield's 'a's
--              |    | |
--              v    v v
take ::  Int -&gt; Pipe a a IO ()
take n = do
    replicateM_ n $ do                     -- Repeat this block 'n' times
        x &lt;- await                         -- 'await' a value of type 'a'
        yield x                            -- 'yield' a value of type 'a'
    lift $ putStrLn &quot;You shall not pass!&quot;  -- Fly, you fools!</pre><p>You can use <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s to transform <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s, <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s, or even other
    <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s using the same (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) operator:</p><pre> (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m r -&gt; <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>   a b m r -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> b m r
 (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>   a b m r -&gt; <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> b m r -&gt; <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code> a m r
 (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>   a b m r -&gt; <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>   b c m r -&gt; <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>   a c m r
</pre><p>For example, you can compose <code><a href="Pipes-Prelude.html#v:take">take</a></code> after <code><a href="Pipes-Prelude.html#v:stdinLn">stdinLn</a></code> to limit the number
    of lines drawn from standard input:</p><pre>maxInput :: Int -&gt; Producer String IO ()
maxInput n = P.stdinLn &gt;-&gt; take n</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ maxInput 3 &gt;-&gt; P.stdoutLn
</code></strong>Test&lt;Enter&gt;
Test
ABC&lt;Enter&gt;
ABC
42&lt;Enter&gt;
42
You shall not pass!
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>
</code></strong></pre><p>... or you can pre-compose <code><a href="Pipes-Prelude.html#v:take">take</a></code> before <code><a href="Pipes-Prelude.html#v:stdoutLn">stdoutLn</a></code> to limit the number
    of lines written to standard output:</p><pre>maxOutput :: Int -&gt; Consumer String IO ()
maxOutput n = take n &gt;-&gt; P.stdoutLn</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ P.stdinLn &gt;-&gt; maxOutput 3
</code></strong>&lt;Exact same behavior&gt;
</pre><p>Those both gave the same behavior because (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) is associative:</p><pre>(p1 &gt;-&gt; p2) &gt;-&gt; p3 = p1 &gt;-&gt; (p2 &gt;-&gt; p3)</pre><p>Therefore we can just leave out the parentheses:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ P.stdinLn &gt;-&gt; take 3 &gt;-&gt; P.stdoutLn
</code></strong>&lt;Exact same behavior&gt;
</pre><p>(<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) is designed to behave like the Unix pipe operator, except with less
    quirks.  In fact, we can continue the analogy to Unix by defining <code><a href="Pipes.html#v:cat">cat</a></code>
    (named after the Unix <code>cat</code> utility), which reforwards elements endlessly:</p><pre>cat :: Monad m =&gt; Pipe a a m r
cat = forever $ do
    x &lt;- await
    yield x</pre><p><code><a href="Pipes.html#v:cat">cat</a></code> is the identity of (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>), meaning that <code><a href="Pipes.html#v:cat">cat</a></code> satisfies the
     following two laws:</p><pre>-- Useless use of 'cat'
cat &gt;-&gt; p = p

-- Forwarding output to 'cat' does nothing
p &gt;-&gt; cat = p</pre><p>Therefore, (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) and <code><a href="Pipes.html#v:cat">cat</a></code> form a <code><a href="../base-4.9.1.0/Control-Category.html#t:Category">Category</a></code>, specifically the category of
    Unix pipes, and <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s are also composable.</p><p>A lot of Unix tools have very simple definitions when written using <code>pipes</code>:</p><pre>-- unix.hs

import Control.Monad (forever)
import Pipes
import qualified Pipes.Prelude as P  -- Pipes.Prelude provides 'take', too
import Prelude hiding (head)

head :: Monad m =&gt; Int -&gt; Pipe a a m ()
head = P.take

yes :: Monad m =&gt; Producer String m r
yes = forever $ yield &quot;y&quot;

main = runEffect $ yes &gt;-&gt; head 3 &gt;-&gt; P.stdoutLn</pre><p>This prints out 3 '<code>y</code>'s, just like the equivalent Unix pipeline:</p><pre>$ ./unix
y
y
y
$ yes | head -3
y
y
y
$</pre><p>This lets us write &quot;Haskell pipes&quot; instead of Unix pipes.  These are much
    easier to build than Unix pipes and we can connect them directly within
    Haskell for interoperability with the Haskell language and ecosystem.</p></div><h1 id="g:6">ListT</h1><div class="doc"><p><code>pipes</code> also provides a &quot;ListT done right&quot; implementation.  This differs
    from the implementation in <code>transformers</code> because this <code><a href="Pipes.html#t:ListT">ListT</a></code>:</p><ul><li>obeys the monad laws, and</li><li>streams data immediately instead of collecting all results into memory.</li></ul><p>The latter property is actually an elegant consequence of obeying the monad
    laws.</p><p>To bind a list within a <code><a href="Pipes.html#t:ListT">ListT</a></code> computation, combine <code><a href="Pipes.html#v:Select">Select</a></code> and <code><a href="Pipes.html#v:each">each</a></code>:</p><pre>import Pipes

pair :: ListT IO (Int, Int)
pair = do
    x &lt;- Select $ each [1, 2]
    lift $ putStrLn $ &quot;x = &quot; ++ show x
    y &lt;- Select $ each [3, 4]
    lift $ putStrLn $ &quot;y = &quot; ++ show y
    return (x, y)</pre><p>You can then loop over a <code><a href="Pipes.html#t:ListT">ListT</a></code> by using <code><a href="Pipes.html#v:every">every</a></code>:</p><pre> <code><a href="Pipes.html#v:every">every</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes.html#t:ListT">ListT</a></code> m a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m ()
</pre><p>So you can use your <code><a href="Pipes.html#t:ListT">ListT</a></code> within a <code><a href="Pipes.html#v:for">for</a></code> loop:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ for (every pair) (lift . print)
</code></strong>x = 1
y = 3
(1,3)
y = 4
(1,4)
x = 2
y = 3
(2,3)
y = 4
(2,4)
</pre><p>... or a pipeline:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import qualified Pipes.Prelude as P
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ every pair &gt;-&gt; P.print
</code></strong>&lt;Exact same behavior&gt;
</pre><p>Note that <code><a href="Pipes.html#t:ListT">ListT</a></code> is lazy and only produces as many elements as we request:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ for (every pair &gt;-&gt; P.take 2) (lift . print)
</code></strong>x = 1
y = 3
(1,3)
y = 4
(1,4)
</pre><p>You can also go the other way, binding <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s directly within a
    <code><a href="Pipes.html#t:ListT">ListT</a></code>.  In fact, this is actually what <code><a href="Pipes.html#v:Select">Select</a></code> was already doing:</p><pre> <code><a href="Pipes.html#v:Select">Select</a></code> :: <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m () -&gt; <code><a href="Pipes.html#t:ListT">ListT</a></code> m a
</pre><p>This lets you write crazy code like:</p><pre>import Pipes
import qualified Pipes.Prelude as P

input :: Producer String IO ()
input = P.stdinLn &gt;-&gt; P.takeWhile (/= &quot;quit&quot;)

name :: ListT IO String
name = do
    firstName &lt;- Select input
    lastName  &lt;- Select input
    return (firstName ++ &quot; &quot; ++ lastName)</pre><p>Here we're binding standard input non-deterministically (twice) as if it
    were an effectful list:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ every name &gt;-&gt; P.stdoutLn
</code></strong>Daniel&lt;Enter&gt;
Fischer&lt;Enter&gt;
Daniel Fischer
Wagner&lt;Enter&gt;
Daniel Wagner
quit&lt;Enter&gt;
Donald&lt;Enter&gt;
Stewart&lt;Enter&gt;
Donald Stewart
Duck&lt;Enter&gt;
Donald Duck
quit&lt;Enter&gt;
quit&lt;Enter&gt;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>
</code></strong></pre><p>Notice how this streams out values immediately as they are generated, rather
    than building up a large intermediate result and then printing all the
    values in one batch at the end.</p><p><code><a href="Pipes.html#t:ListT">ListT</a></code> computations can be combined in more ways than <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s, so try to
    program in <code><a href="Pipes.html#t:ListT">ListT</a></code> as much as possible and defer converting it to a <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>
    as late as possible using <code><a href="Pipes-Prelude.html#v:loop">loop</a></code>.</p><p>You can combine <code><a href="Pipes.html#t:ListT">ListT</a></code> computations even if their inputs and outputs are
    completely different:</p><pre>data In
    = InA A
    | InB B
    | InC C

data Out
    = OutD D
    | OutE E
    | OutF F

-- Independent computations

example1 :: A -&gt; ListT IO D
example2 :: B -&gt; ListT IO E
example3 :: C -&gt; ListT IO F

-- Combined computation

total :: In -&gt; ListT IO Out
total input = case input of
    InA a -&gt; fmap OutD (example1 a)
    InB b -&gt; fmap OutE (example2 b)
    InC c -&gt; fmap OutF (example3 c)</pre><p>Sometimes you have multiple computations that handle different inputs but
    the same output, in which case you don't need to unify their outputs:</p><pre>-- Overlapping outputs

example1 :: A -&gt; ListT IO Out
example2 :: B -&gt; ListT IO Out
example3 :: C -&gt; ListT IO Out

-- Combined computation

total :: In -&gt; ListT IO Out
total input = case input of
    InA a -&gt; example1 a
    InB b -&gt; example2 b
    InC c -&gt; example3 c</pre><p>Other times you have multiple computations that handle the same input but
    produce different outputs.  You can unify their outputs using the <code><a href="../base-4.9.1.0/Data-Monoid.html#t:Monoid">Monoid</a></code>
    and <code><a href="../base-4.9.1.0/Data-Functor.html#t:Functor">Functor</a></code> instances for <code><a href="Pipes.html#t:ListT">ListT</a></code>:</p><pre>-- Overlapping inputs

example1 :: In -&gt; ListT IO D
example2 :: In -&gt; ListT IO E
example3 :: In -&gt; ListT IO F

-- Combined computation

total :: In -&gt; ListT IO Out
total input =
       fmap OutD (example1 input)
    &lt;&gt; fmap OutE (example2 input)
    &lt;&gt; fmap OutF (example3 input)</pre><p>You can also chain <code><a href="Pipes.html#t:ListT">ListT</a></code> computations, feeding the output of the first
    computation as the input to the next computation:</p><pre>-- End-to-end

aToB :: A -&gt; ListT IO B
bToC :: B -&gt; ListT IO C

-- Combined computation

aToC :: A -&gt; LIstT IO C
aToC = aToB &gt;=&gt; bToC</pre><p>... or you can just use <code>do</code> notation if you prefer.</p><p>However, the <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> type is more general than <code><a href="Pipes.html#t:ListT">ListT</a></code> and can represent
    things like termination.  Therefore you should consider mixing <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s with
    <code><a href="Pipes.html#t:ListT">ListT</a></code> when you need to take advantage of these extra features:</p><pre>-- Mix ListT with Pipes

example :: In -&gt; ListT IO Out

pipe :: Pipe In Out IO ()
pipe = Pipes.takeWhile (not . isC) &gt;-&gt; loop example
  where
    isC (InC _) = True
    isC  _      = False</pre><p>So promote your <code><a href="Pipes.html#t:ListT">ListT</a></code> logic to a <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> when you need to take advantage of
    these <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>-specific features.</p></div><h1 id="g:7">Tricks</h1><div class="doc"><p><code>pipes</code> is more powerful than meets the eye so this section presents some
    non-obvious tricks you may find useful.</p><p>Many pipe combinators will work on unusual pipe types and the next few
    examples will use the <code><a href="Pipes.html#v:cat">cat</a></code> pipe to demonstrate this.</p><p>For example, you can loop over the output of a <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> using <code><a href="Pipes.html#v:for">for</a></code>, which is
    how <code><a href="Pipes-Prelude.html#v:map">map</a></code> is defined:</p><pre>map :: Monad m =&gt; (a -&gt; b) -&gt; Pipe a b m r
map f = for cat $ \x -&gt; yield (f x)

-- Read this as: For all values flowing downstream, apply 'f'</pre><p>This is equivalent to:</p><pre>map f = forever $ do
    x &lt;- await
    yield (f x)</pre><p>You can also feed a <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> input using (<code><a href="Pipes.html#v:-62--126-">&gt;~</a></code>).  This means we could have
    instead defined the <code>yes</code> pipe like this:</p><pre>yes :: Monad m =&gt; Producer String m r
yes = return &quot;y&quot; &gt;~ cat

-- Read this as: Keep feeding &quot;y&quot; downstream</pre><p>This is equivalent to:</p><pre>yes = forever $ yield &quot;y&quot;</pre><p>You can also sequence two <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s together.  This is how <code><a href="Pipes-Prelude.html#v:drop">drop</a></code> is
    defined:</p><pre>drop :: Monad m =&gt; Int -&gt; Pipe a a m r
drop n = do
    replicateM_ n await
    cat</pre><p>This is equivalent to:</p><pre>drop n = do
    replicateM_ n await
    forever $ do
        x &lt;- await
        yield x</pre><p>You can even compose pipes inside of another pipe:</p><pre>customerService :: Producer String IO ()
customerService = do
    each [ &quot;Hello, how can I help you?&quot;        -- Begin with a script
         , &quot;Hold for one second.&quot;
         ]
    P.stdinLn &gt;-&gt; P.takeWhile (/= &quot;Goodbye!&quot;)  -- Now continue with a human</pre><p>Also, you can often use <code><a href="Pipes.html#v:each">each</a></code> in conjunction with (<code><a href="Pipes.html#v:-126--62-">~&gt;</a></code>) to traverse nested
    data structures.  For example, you can print all non-<code><a href="../base-4.9.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> elements
    from a doubly-nested list:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ (each ~&gt; each ~&gt; each ~&gt; lift . print) [[Just 1, Nothing], [Just 2, Just 3]]
</code></strong>1
2
3
</pre><p>Another neat thing to know is that <code><a href="Pipes.html#v:every">every</a></code> has a more general type:</p><pre> <code><a href="Pipes.html#v:every">every</a></code> :: (<code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m, <code><a href="Pipes.html#t:Enumerable">Enumerable</a></code> t) =&gt; t m a -&gt; <code><a href="Pipes-Core.html#t:Producer">Producer</a></code> a m ()
</pre><p><code><a href="Pipes.html#t:Enumerable">Enumerable</a></code> generalizes <code><a href="Pipes.html#t:Foldable">Foldable</a></code> and if you have an effectful container
    of your own that you want others to traverse using <code>pipes</code>, just have your
    container implement the <code><a href="Pipes.html#v:toListT">toListT</a></code> method of the <code><a href="Pipes.html#t:Enumerable">Enumerable</a></code> class:</p><pre>class Enumerable t where
    toListT :: Monad m =&gt; t m a -&gt; ListT m a</pre><p>You can even use <code><a href="Pipes.html#t:Enumerable">Enumerable</a></code> to traverse effectful types that are not even
    proper containers, like <code><a href="../transformers-0.5.2.0/Control-Monad-Trans-Maybe.html#v:MaybeT">MaybeT</a></code>:</p><pre>input :: MaybeT IO String
input = do
    str &lt;- lift getLine
    guard (str /= &quot;Fail&quot;)
    return str</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ every input &gt;-&gt; P.stdoutLn
</code></strong>Test&lt;Enter&gt;
Test
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect $ every input &gt;-&gt; P.stdoutLn
</code></strong>Fail&lt;Enter&gt;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>
</code></strong></pre></div><h1 id="g:8">Conclusion</h1><div class="doc"><p>This tutorial covers the concepts of connecting, building, and reading
    <code>pipes</code> code.  However, this library is only the core component in an
    ecosystem of streaming components.  Derived libraries that build immediately
    upon <code>pipes</code> include:</p><ul><li><code>pipes-concurrency</code>: Concurrent reactive programming and message passing</li><li><code>pipes-parse</code>: Minimal utilities for stream parsing</li><li><code>pipes-safe</code>: Resource management and exception safety for <code>pipes</code></li><li><code>pipes-group</code>: Grouping streams in constant space</li></ul><p>These libraries provide functionality specialized to common streaming
    domains.  Additionally, there are several libraries on Hackage that provide
    even higher-level functionality, which you can find by searching under the
    &quot;Pipes&quot; category or by looking for packages with a <code>pipes-</code> prefix in
    their name.  Current examples include:</p><ul><li><code>pipes-extras</code>: Miscellaneous utilities</li><li><code>pipes-network</code>/<code>pipes-network-tls</code>: Networking</li><li><code>pipes-zlib</code>: Compression and decompression</li><li><code>pipes-binary</code>: Binary serialization</li><li><code>pipes-attoparsec</code>: High-performance parsing</li><li><code>pipes-aeson</code>: JSON serialization and deserialization</li></ul><p>Even these derived packages still do not explore the full potential of
    <code>pipes</code> functionality, which actually permits bidirectional communication.
    Advanced <code>pipes</code> users can explore this library in greater detail by
    studying the documentation in the <a href="Pipes-Core.html">Pipes.Core</a> module to learn about the
    symmetry of the underlying <code><a href="Pipes-Internal.html#t:Proxy">Proxy</a></code> type and operators.</p><p>To learn more about <code>pipes</code>, ask questions, or follow <code>pipes</code> development,
    you can subscribe to the <code>haskell-pipes</code> mailing list at:</p><p><a href="https://groups.google.com/forum/#!forum/haskell-pipes">https://groups.google.com/forum/#!forum/haskell-pipes</a></p><p>... or you can mail the list directly at:</p><p><a href="mailto:haskell-pipes@googlegroups.com">mailto:haskell-pipes@googlegroups.com</a></p><p>Additionally, for questions regarding types or type errors, you might find
    the following appendix on types very useful.</p></div><h1 id="g:9">Appendix: Types</h1><div class="doc"><p><code>pipes</code> uses parametric polymorphism (i.e. generics) to overload all
    operations.  You've probably noticed this overloading already:</p><ul><li><code><a href="Pipes.html#v:yield">yield</a></code> works within both <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s and <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s</li><li><code><a href="Pipes.html#v:await">await</a></code> works within both <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s and <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s</li><li>(<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) connects <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s, <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s, and <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s in varying ways</li></ul><p>This overloading is great when it works, but when connections fail they
    produce type errors that appear intimidating at first.  This section
    explains the underlying types so that you can work through type errors
    intelligently.</p><p><code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s, <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>s, <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>s, and <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>s are all special cases of a
    single underlying type: a <code><a href="Pipes-Internal.html#t:Proxy">Proxy</a></code>.  This overarching type permits fully
    bidirectional communication on both an upstream and downstream interface.
    You can think of it as having the following shape:</p><pre>Proxy a' a b' b m r

Upstream | Downstream
    +---------+
    |         |
a' &lt;==       &lt;== b'  -- Information flowing upstream
    |         |
a  ==&gt;       ==&gt; b   -- Information flowing downstream
    |    |    |
    +----|----+
         v
         r</pre><p>The four core types do not use the upstream flow of information.  This means
    that the <code>a'</code> and <code>b'</code> in the above diagram go unused unless you use the
    more advanced features provided in <a href="Pipes-Core.html">Pipes.Core</a>.</p><p><code>pipes</code> uses type synonyms to hide unused inputs or outputs and clean up
    type signatures.  These type synonyms come in two flavors:</p><ul><li>Concrete type synonyms that explicitly close unused inputs and outputs of
      the <code><a href="Pipes-Internal.html#t:Proxy">Proxy</a></code> type</li><li>Polymorphic type synonyms that don't explicitly close unused inputs or
      outputs</li></ul><p>The concrete type synonyms use <code>()</code> to close unused inputs and <code><a href="Pipes-Internal.html#t:X">X</a></code> (the
    uninhabited type) to close unused outputs:</p><ul><li><code><a href="Pipes-Core.html#t:Effect">Effect</a></code>: explicitly closes both ends, forbidding <code><a href="Pipes.html#v:await">await</a></code>s and <code><a href="Pipes.html#v:yield">yield</a></code>s</li></ul><pre>type Effect = Proxy X () () X

 Upstream | Downstream
    +---------+
    |         |
X  &lt;==       &lt;== ()
    |         |
() ==&gt;       ==&gt; X
    |    |    |
    +----|----+
         v
         r</pre><ul><li><code><a href="Pipes-Core.html#t:Producer">Producer</a></code>: explicitly closes the upstream end, forbidding <code><a href="Pipes.html#v:await">await</a></code>s</li></ul><pre>type Producer b = Proxy X () () b

Upstream | Downstream
    +---------+
    |         |
X  &lt;==       &lt;== ()
    |         |
() ==&gt;       ==&gt; b
    |    |    |
    +----|----+
         v
         r</pre><ul><li><code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>: explicitly closes the downstream end, forbidding <code><a href="Pipes.html#v:yield">yield</a></code>s</li></ul><pre>type Consumer a = Proxy () a () X

Upstream | Downstream
    +---------+
    |         |
() &lt;==       &lt;== ()
    |         |
a  ==&gt;       ==&gt; X
    |    |    |
    +----|----+
         v
         r</pre><ul><li><code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>: marks both ends open, allowing both <code><a href="Pipes.html#v:await">await</a></code>s and <code><a href="Pipes.html#v:yield">yield</a></code>s</li></ul><pre>type Pipe a b = Proxy () a () b

Upstream | Downstream
    +---------+
    |         |
() &lt;==       &lt;== ()
    |         |
a  ==&gt;       ==&gt; b
    |    |    |
    +----|----+
         v
         r</pre><p>When you compose <code><a href="Pipes-Internal.html#t:Proxy">Proxy</a></code>s using (<code><a href="Pipes.html#v:-62--45--62-">&gt;-&gt;</a></code>) all you are doing is placing them
    side by side and fusing them laterally.  For example, when you compose a
    <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>, <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>, and a <code><a href="Pipes-Core.html#t:Consumer">Consumer</a></code>, you can think of information flowing
    like this:</p><pre>       Producer                Pipe                 Consumer
    +-----------+          +----------+          +------------+
    |           |          |          |          |            |
X  &lt;==         &lt;==   ()   &lt;==        &lt;==   ()   &lt;==          &lt;== ()
    |  stdinLn  |          |  take 3  |          |  stdoutLn  |
() ==&gt;         ==&gt; String ==&gt;        ==&gt; String ==&gt;          ==&gt; X
    |     |     |          |    |     |          |      |     |
    +-----|-----+          +----|-----+          +------|-----+
          v                     v                       v
          ()                    ()                      ()</pre><p>Composition fuses away the intermediate interfaces, leaving behind an
     <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>:</p><pre>                   Effect
    +-----------------------------------+
    |                                   |
X  &lt;==                                 &lt;== ()
    |  stdinLn &gt;-&gt; take 3 &gt;-&gt; stdoutLn  |
() ==&gt;                                 ==&gt; X
    |                                   |
    +----------------|------------------+
                     v
                     ()</pre><p><code>pipes</code> also provides polymorphic type synonyms with apostrophes at the end
    of their names.  These use universal quantification to leave open any unused
    input or output ends (which I mark using <code>*</code>):</p><ul><li><code><a href="Pipes-Core.html#t:Producer-39-">Producer'</a></code>: marks the upstream end unused but still open</li></ul><pre>type Producer' b m r = forall x' x . Proxy x' x () b m r

Upstream | Downstream
    +---------+
    |         |
 * &lt;==       &lt;== ()
    |         |
 * ==&gt;       ==&gt; b
    |    |    |
    +----|----+
         v
         r</pre><ul><li><code><a href="Pipes-Core.html#t:Consumer-39-">Consumer'</a></code>: marks the downstream end unused but still open</li></ul><pre>type Consumer' a m r = forall y' y . Proxy () a y' y m r

Upstream | Downstream
    +---------+
    |         |
() &lt;==       &lt;== * 
    |         |
a  ==&gt;       ==&gt; *
    |    |    |
    +----|----+
         v
         r</pre><ul><li><code><a href="Pipes-Core.html#t:Effect-39-">Effect'</a></code>: marks both ends unused but still open</li></ul><pre>type Effect' m r = forall x' x y' y . Proxy x' x y' y m r

Upstream | Downstream
    +---------+
    |         |
 * &lt;==       &lt;== * 
    |         |
 * ==&gt;       ==&gt; *
    |    |    |
    +----|----+
         v
         r</pre><p>Note that there is no polymorphic generalization of a <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>.</p><p>Like before, if you compose a <code><a href="Pipes-Core.html#t:Producer-39-">Producer'</a></code>, a <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>, and a <code><a href="Pipes-Core.html#t:Consumer-39-">Consumer'</a></code>:</p><pre>       Producer'               Pipe                 Consumer'
    +-----------+          +----------+          +------------+
    |           |          |          |          |            |
 * &lt;==         &lt;==   ()   &lt;==        &lt;==   ()   &lt;==          &lt;== *
    |  stdinLn  |          |  take 3  |          |  stdoutLn  |
 * ==&gt;         ==&gt; String ==&gt;        ==&gt; String ==&gt;          ==&gt; *
    |     |     |          |     |    |          |      |     |
    +-----|-----+          +-----|----+          +------|-----+
          v                      v                      v
          ()                     ()                     ()</pre><p>... they fuse into an <code><a href="Pipes-Core.html#t:Effect-39-">Effect'</a></code>:</p><pre>                   Effect'
    +-----------------------------------+
    |                                   |
 * &lt;==                                 &lt;== *
    |  stdinLn &gt;-&gt; take 3 &gt;-&gt; stdoutLn  |
 * ==&gt;                                 ==&gt; *
    |                                   |
    +----------------|------------------+
                     v
                     ()</pre><p>Polymorphic type synonyms come in handy when you want to keep the type as
    general as possible.  For example, the type signature for <code><a href="Pipes.html#v:yield">yield</a></code> uses
    <code><a href="Pipes-Core.html#t:Producer-39-">Producer'</a></code> to keep the type signature simple while still leaving the
    upstream input end open:</p><pre> <code><a href="Pipes.html#v:yield">yield</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; a -&gt; <code><a href="Pipes-Core.html#t:Producer-39-">Producer'</a></code> a m ()
</pre><p>This type signature lets us use <code><a href="Pipes.html#v:yield">yield</a></code> within a <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>, too, because the
    <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> type synonym is a special case of the polymorphic <code><a href="Pipes-Core.html#t:Producer-39-">Producer'</a></code> type 
    synonym:</p><pre> type <code><a href="Pipes-Core.html#t:Producer-39-">Producer'</a></code> b m r = forall x' x . <code><a href="Pipes-Internal.html#t:Proxy">Proxy</a></code> x' x () b m r
 type <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>    a b m r =               <code><a href="Pipes-Internal.html#t:Proxy">Proxy</a></code> () a () b m r
</pre><p>The same is true for <code><a href="Pipes.html#v:await">await</a></code>, which uses the polymorphic <code><a href="Pipes-Core.html#t:Consumer-39-">Consumer'</a></code> type
    synonym:</p><pre> <code><a href="Pipes.html#v:await">await</a></code> :: <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> m =&gt; <code><a href="Pipes-Core.html#t:Consumer-39-">Consumer'</a></code> a m a
</pre><p>We can use <code><a href="Pipes.html#v:await">await</a></code> within a <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> because a <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code> is a special case of the
    polymorphic <code><a href="Pipes-Core.html#t:Consumer-39-">Consumer'</a></code> type synonym:</p><pre> type <code><a href="Pipes-Core.html#t:Consumer-39-">Consumer'</a></code> a   m r = forall y' y . <code><a href="Pipes-Internal.html#t:Proxy">Proxy</a></code> () a y' y m r
 type <code><a href="Pipes-Core.html#t:Pipe">Pipe</a></code>      a b m r =               <code><a href="Pipes-Internal.html#t:Proxy">Proxy</a></code> () a () b m r
</pre><p>However, polymorphic type synonyms cause problems in many other cases:</p><ul><li>They usually give the wrong behavior when used as the argument of a
      function (known as the &quot;negative&quot; or &quot;contravariant&quot; position) like
      this:</li></ul><pre>f :: Producer' a m r -&gt; ...  -- Wrong

f :: Producer  a m r -&gt; ...  -- Right</pre><p>The former function only accepts polymorphic <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s as arguments.
      The latter function accepts both polymorphic and concrete <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>s,
      which is probably what you want.</p><ul><li>Even when you desire a polymorphic argument, this induces a higher-ranked
      type, because it translates to a <code>forall</code> which you cannot factor out to
      the top-level to simplify the type signature:</li></ul><pre>f :: (forall x' x y' . Proxy x' x y' m r) -&gt; ...</pre><p>These kinds of type signatures require the <code>RankNTypes</code> extension.</p><ul><li>Even when you have polymorphic type synonyms as the result of a function
      (i.e.  the &quot;positive&quot; or &quot;covariant&quot; position), recent versions of
      <code>ghc</code> such still require the <code>RankNTypes</code> extension.  For example, the
      <code><a href="Pipes-Prelude.html#v:fromHandle">fromHandle</a></code> function from <a href="Pipes-Prelude.html">Pipes.Prelude</a> requires
      <code>RankNTypes</code> to compile correctly on <code>ghc-7.6.3</code>:</li></ul><pre>fromHandle :: MonadIO m =&gt; Handle -&gt; Producer' String m ()</pre><ul><li>You can't use polymorphic type synonyms inside other type constructors
      without the <code>ImpredicativeTypes</code> extension:</li></ul><pre>io :: IO (Producer' a m r)  -- Type error without ImpredicativeTypes</pre><ul><li>You can't partially apply polymorphic type synonyms:</li></ul><pre>stack :: MaybeT (Producer' a m) r  -- Type error</pre><p>In these scenarios you should fall back on the concrete type synonyms, which
    are better behaved.  If concrete type synonyms are unsatisfactory, then ask
    <code>ghc</code> to infer the most general type signature and use that.</p><p>For the purposes of debugging type errors you can just remember that:</p><pre> Input --+    +-- Output
         |    |
         v    v
Proxy a' a b' b m r
      ^    ^
      |    |
      +----+-- Ignore these</pre><p>For example, let's say that you try to run the <code><a href="Pipes-Prelude.html#v:stdinLn">stdinLn</a></code> <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>.  This
    produces the following type error:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>runEffect P.stdinLn
</code></strong>&lt;interactive&gt;:4:5:
    Couldn't match expected type `X' with actual type `String'
    Expected type: Effect m0 r0
      Actual type: Proxy X () () String IO ()
    In the first argument of `runEffect', namely `P.stdinLn'
    In the expression: runEffect P.stdinLn
</pre><p><code><a href="Pipes-Core.html#v:runEffect">runEffect</a></code> expects an <code><a href="Pipes-Core.html#t:Effect">Effect</a></code>, which is equivalent to the following type:</p><pre>Effect          IO () = Proxy X () () X      IO ()</pre><p>... but <code><a href="Pipes-Prelude.html#v:stdinLn">stdinLn</a></code> type-checks as a <code><a href="Pipes-Core.html#t:Producer">Producer</a></code>, which has the following
    type:</p><pre>Producer String IO () = Proxy X () () String IO ()</pre><p>The fourth type variable (the output) does not match.  For an <code><a href="Pipes-Core.html#t:Effect">Effect</a></code> this
    type variable should be closed (i.e. <code><a href="Pipes-Internal.html#t:X">X</a></code>), but <code><a href="Pipes-Prelude.html#v:stdinLn">stdinLn</a></code> has a <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>
    output, thus the type error:</p><pre>   Couldn't match expected type `X' with actual type `String'</pre><p>Any time you get type errors like these you can work through them by
    expanding out the type synonyms and seeing which type variables do not
    match.</p><p>You may also consult this table of type synonyms to more easily compare
    them:</p><pre>type Effect             = Proxy X  () () X
type Producer         b = Proxy X  () () b
type Consumer    a      = Proxy () a  () X
type Pipe        a    b = Proxy () a  () b

type Server        b' b = Proxy X  () b' b 
type Client   a' a      = Proxy a' a  () X

type Effect'            m r = forall x' x y' y . Proxy x' x y' y m r
type Producer'        b m r = forall x' x      . Proxy x' x () b m r
type Consumer'   a      m r = forall      y' y . Proxy () a y' y m r

type Server'       b' b m r = forall x' x      . Proxy x' x b' b m r
type Client'  a' a      m r = forall      y' y . Proxy a' a y' y m r</pre></div><h1 id="g:10">Appendix: Time Complexity</h1><div class="doc"><p>There are three functions that give quadratic time complexity when used in
    within <code>pipes</code>:</p><ul><li><code><a href="../base-4.9.1.0/Data-Traversable.html#v:sequence">sequence</a></code></li><li><code><a href="../base-4.9.1.0/Control-Monad.html#v:replicateM">replicateM</a></code></li><li><code><a href="../base-4.9.1.0/Data-Traversable.html#v:mapM">mapM</a></code></li></ul><p>For example, the time complexity of this code segment scales quadratically
    with <code>n</code>:</p><pre>import Control.Monad (replicateM)
import Pipes

quadratic :: Int -&gt; Consumer a m [a]
quadratic n = replicateM n await</pre><p>These three functions are generally bad practice to use, because all three
    of them correspond to &quot;ListT done wrong&quot;, building a list in memory
    instead of streaming results.</p><p>However, sometimes situations arise where one deliberately intends to build
    a list in memory.  The solution is to use the &quot;codensity transformation&quot;
    to transform the code to run with linear time complexity.  This involves:</p><ul><li>wrapping the code in the <code>Codensity</code> monad transformer (from
      <code>Control.Monad.Codensity</code> module of the <code>kan-extensions</code> package) using
      <code><a href="../mmorph-1.0.9/Control-Monad-Morph.html#v:lift">lift</a></code></li><li>applying <code><a href="../base-4.9.1.0/Data-Traversable.html#v:sequence">sequence</a></code> / <code><a href="../base-4.9.1.0/Control-Monad.html#v:replicateM">replicateM</a></code> / <code><a href="../base-4.9.1.0/Data-Traversable.html#v:mapM">mapM</a></code></li><li>unwrapping the code using <code>lowerCodensity</code></li></ul><p>To illustrate this, we'd transform the above example to:</p><pre>import Control.Monad.Codensity (lowerCodensity)

linear :: Monad m =&gt; Int -&gt; Consumer a m [a]
linear n = lowerCodensity $ replicateM n $ lift await</pre><p>This will produce the exact same result, but in linear time.</p></div><h1 id="g:11">Copyright</h1><div class="doc"><p>This tutorial is licensed under a
    <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>